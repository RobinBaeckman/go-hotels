version: "3.44.1"

dotenv:
  - ".env"

vars:
  GHCR_USER: robinbaeckman
  IMAGE_NAME: ghcr.io/{{.GHCR_USER | lower}}/go-hotels
  IMAGE_TAG: '{{.GITHUB_SHA | default "dev"}}'

tasks:
  # ---------------------
  # Code Generation
  # ---------------------
  api-gen:
    desc: Generate Go code from OpenAPI spec
    cmds:
      - go tool oapi-codegen -config api/oapi-codegen.cfg.yaml api/openapi.yaml
    sources:
      - api/openapi.yaml
      - api/oapi-codegen.cfg.yaml
    generates:
      - api/openapi.gen.go

  db-gen:
    desc: Generate Go code from SQL using sqlc
    cmds:
      - go tool sqlc generate

  # ---------------------
  # Database
  # ---------------------
  migrate-install:
    internal: true
    cmds:
      - |
        if ! command -v migrate > /dev/null; then
          echo "üì¶ Installing migrate..."
          go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@v4.17.0

          if [ "${CI}" = "true" ]; then
            echo "${HOME}/go/bin" >> $GITHUB_PATH
          fi
        fi

  migrate-up:
    desc: Apply all up migrations
    deps: [migrate-install]
    cmds:
      - migrate -database "$DATABASE_URL" -path migrations up

  migrate-down:
    desc: Roll back the last migration
    cmds:
      - migrate -database "$DATABASE_URL" -path migrations down 1

  db-up:
    desc: Start DB, wait until it's reachable, apply migrations, and generate SQL code
    cmds:
      - docker compose up -d db
      - |
        echo "‚è≥ Waiting for DB to be reachable on port 5432..."
        until nc -z localhost 5432; do
          sleep 1
        done
        echo "‚úÖ DB is accepting connections"
      - task: migrate-up
      - task: db-gen

  db-down:
    desc: Stop only the database container
    cmds:
      - docker compose stop db

  db-reset:
    desc: Reset DB by restarting it and reapplying all migrations
    cmds:
      - task: db-down
      - task: db-up
  # ---------------------
  # API
  # ---------------------
  api-run:
    desc: Run the REST server locally
    cmds:
      - go run ./cmd/rest

  api-up:
    desc: Start API service via docker-compose and wait for it
    cmds:
      - docker compose up -d api
      - |
        echo "‚è≥ Waiting for API at http://localhost:8080/ready..."
        for i in {1..30}; do
          if curl -sf http://localhost:8080/ready; then
            echo "‚úÖ API is ready"
            exit 0
          fi
          sleep 1
        done
        echo "‚ùå API not ready after 30s"
        docker compose logs api
        exit 1

  api-down:
    desc: Stop API service
    cmds:
      - docker compose stop api

  api-log:
    desc: View logs for API container
    cmds:
      - docker compose logs api

  # ---------------------
  # Compose Orchestration
  # ---------------------
  all-up:
    desc: Start full system (API + DB)
    cmds:
      - task: db-up
      - task: api-up

  all-down:
    desc: Stop full system and remove volumes
    cmds:
      - docker compose down -v

  # ---------------------
  # Testing
  # ---------------------
  test-load:
    desc: Run all load tests (stress + soak) and summarize
    cmds:
      - |
        if [ "${CI}" != "true" ]; then
        else
          task migrate-up
        fi
      - task db-gen
      - |
        if [ "${CI}" = "true" ]; then
          echo "üöÄ Starting API with go run"
          go run ./cmd/rest &
        else
        fi
      - echo "‚è≥ Waiting for API at http://localhost:8080/ready..."
      - |
        for i in {1..30}; do
          if curl --fail http://localhost:8080/ready > /dev/null 2>&1; then
            echo "‚úÖ API is ready!"
            break
          fi
          sleep 1
        done
        if ! curl --fail http://localhost:8080/ready > /dev/null 2>&1; then
          echo "‚ùå API never became ready"
          exit 1
        fi
      - mkdir -p test/load/results
      - echo "Running stress GET test..."
      - k6 run test/load/stress-get.js > test/load/results/stress-get.log
      - echo "Running stress POST test..."
      - k6 run test/load/stress-post.js > test/load/results/stress-post.log
      - echo "Running soak test..."
      - k6 run test/load/soak.js > test/load/results/soak.log
      - echo "Summarizing results..."
      - bash scripts/parse-load-results.sh --legend-only > test/load/summary.txt
      - bash scripts/parse-load-results.sh test/load/results/stress-get.log "Stress GET" >> test/load/summary.txt
      - bash scripts/parse-load-results.sh test/load/results/stress-post.log "Stress POST" >> test/load/summary.txt
      - bash scripts/parse-load-results.sh test/load/results/soak.log "Soak Test" >> test/load/summary.txt
      - cat test/load/summary.txt

  synthetic-traffic:
    desc: "Run continuous synthetic traffic (~30 rps) for 12h"
    cmds:
      - BASE_URL={{.BASE_URL | default "http://localhost:8080"}} k6 run test/load/synthetic-traffic.js

  test-unit:
    desc: Run unit tests (with optional coverage check)
    cmds:
      - |
        if [ "{{.CLI_ARGS}}" = "fast" ]; then
          go test $(go list ./... | grep -v '/test/integration') -v
        else
          go test -coverprofile=coverage.out -covermode=set $(go list ./... | grep -v '/test/integration') -v | grep -v 'coverage:'
          ./scripts/coverage-check.sh
        fi

  test-integration:
    desc: Run Go integration tests (smart for local & CI)
    cmds:
      - |
        if [ "${CI}" != "true" ]; then
          task all-down
          task all-up
        else
          task migrate-up
        fi
      - task db-gen
      - |
        if [ "${CI}" = "true" ]; then
          echo "üöÄ Starting API with go run"
          go run ./cmd/rest &
        else
          task api-up
        fi
      - echo "‚è≥ Waiting for API at http://localhost:8080/ready..."
      - |
        for i in {1..30}; do
          if curl --fail http://localhost:8080/ready > /dev/null 2>&1; then
            echo "‚úÖ API is ready!"
            exit 0
          fi
          sleep 1
        done

        echo "‚ùå API never became ready"
        exit 1    - echo "üöÄ Running Go integration tests"
      - go test -tags=integration ./test/integration/... -v
      - |
        if [ "${CI}" != "true" ]; then
          task all-down
        fi

  test-all:
    desc: Run all tests (unit + integration + coverage)
    cmds:
      - task: test-unit
      - task: test-integration

  # ---------------------
  # Code Quality
  # ---------------------
  fmt:
    desc: Format code (fix issues)
    cmds:
      - go fmt ./...
      - go tool goimports -w .

  fmt-check:
    desc: Fail if code is not formatted
    cmds:
      - test -z "$(go fmt ./...)"
      - test -z "$(go tool goimports -l .)"

  lint:
    desc: Run static analysis with golangci-lint
    cmds:
      - go tool golangci-lint run ./...

  tidy:
    desc: Run go mod tidy and verify
    cmds:
      - git diff --exit-code go.mod go.sum || (echo "‚ùå go.mod or go.sum are not tidy. Run 'go mod tidy' and commit the changes." && exit 1)

  # ---------------------
  # Docker & Security
  # ---------------------
  docker-build:
    desc: Build Docker image for go-hotels with BuildKit
    cmds:
      - DOCKER_BUILDKIT=1 docker build -t {{.IMAGE_NAME}}:{{.IMAGE_TAG}} -t {{.IMAGE_NAME}}:latest .

  docker-push:
    desc: Push Docker image to GHCR
    cmds:
      - echo $GHCR_PAT | docker login ghcr.io -u "{{.GHCR_USER | lower}}" --password-stdin
      - docker push {{.IMAGE_NAME}}:{{.IMAGE_TAG}}
      - docker push {{.IMAGE_NAME}}:latest

  security-check:
    desc: Local scans (gosec, govulncheck, gitleaks)
    deps: [docker-build]
    cmds:
      - echo "üîç Running static code analysis (SAST)..."
      - go tool gosec ./...
      - go tool govulncheck ./...
      - echo "üîç Running secrets scanner (Gitleaks)..."
      - docker run --rm -v $PWD:/repo zricethezav/gitleaks detect --source=/repo

  # ---------------------
  # Observability
  # ---------------------
  observe-up:
    desk: Enables docker compose observability stack
    cmds:
      - docker compose -f docker-compose.yml -f deploy/observe/docker-compose.yml up -d --build

  observe-down:
    desk: Enables docker compose observability stack
    cmds:
      - docker compose -f docker-compose.yml -f deploy/observe/docker-compose.yml down -v

  # ---------------------
  # Misc
  # ---------------------
  hotel-create:
    desc: Create a new hotel via API
    cmds:
      - |
        http POST :8080/hotels \
          name="Hotel Aurora" \
          city="Stockholm" \
          stars:=5 \
          price_per_night:=199.0 \
          amenities:='["wifi","spa","breakfast"]'

  hotel-list:
    desc: List hotels in a city (optional dates)
    cmds:
      - http GET :8080/hotels city==Stockholm checkin==2025-08-15 checkout==2025-08-18

  kill-port:
    desc: Kill process on given port
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "‚ùå You must specify a port: task kill-port -- 8080"
          exit 1
        fi
        PID=$(lsof -ti:{{.CLI_ARGS}})
        if [ -n "$PID" ]; then
          echo "Killing process on port {{.CLI_ARGS}} (PID $PID)"
          kill -9 $PID
        else
          echo "No process running on port {{.CLI_ARGS}}"
        fi

  ci-local:
    desc: Run fast local CI (format, lint, tidy, unit/integration tests, coverage, security)
    cmds:
      - task: fmt-check
      - task: lint
      - task: tidy
      - task: test-unit
      - task: test-integration
      - task: security-check

  env-check:
    desc: Print effective config for debugging
    cmds:
      - |
        echo "üì¶ Printing values from .env"
        set -o allexport
        source .env
        set +o allexport
        while IFS='=' read -r key _; do
          if [[ "$key" =~ ^[A-Z_][A-Z0-9_]*$ ]]; then
            value="${!key}"
            echo "$key=$value"
          fi
        done < <(grep -v '^#' .env | grep '=')

        # Print to GitHub summary if available
        if [ -n "$GITHUB_STEP_SUMMARY" ]; then
          {
            echo "### üîß Effective Environment Variables from .env"
            echo '```env'
            while IFS='=' read -r key _; do
              if [[ "$key" =~ ^[A-Z_][A-Z0-9_]*$ ]]; then
                value="${!key}"
                echo "$key=$value"
              fi
            done < <(grep -v '^#' .env | grep '=')
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"
        fi
  sniff-http2:
    desc: "Capture HTTP (port 8080) traffic live using tcpdump"
    cmds:
      - |
        echo "Starting tcpdump on port 8080 (press Ctrl+C to stop)"
        sudo tcpdump -i lo0 -s 0 -A 'tcp port 8080'

  sniff-http:
    desc: "Sniff HTTP traffic on port 8080 with termshark"
    cmds:
      - echo "Starting termshark on lo0 for port 8080 (press q to quit)"
      - sudo termshark -i lo0 -f "tcp port 8080"

  sniff-http3:
    desc: "Sniff HTTP traffic on port 8080 with termshark"
    cmds:
      - echo "Starting tshark on lo0 for port 8080 (press q to quit)"
      - sudo tshark -i lo0 -f "tcp port 8080" -O http -P
